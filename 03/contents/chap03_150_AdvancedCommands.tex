\newpage
\section{コマンドをつなげて便利に使う}
ラズパイにはコマンドをつなげて便利に使うための方法が用意されています。
コマンドをつなげると、いくつかの処理を連続して行うことができるようになります。
まずは、コマンドが入力・出力をどのように行うのかを理解しましょう。
次に入出力を変更して、コマンドの入力と出力がどのように変わるのかを理解しましょう。
最後に、コマンドをいくつかつなげて、複雑な処理をやってみましょう。

\subsection{コマンドの\ruby{入出力}{にゅう|しゅつ|りょく}}
　コマンドを実行すると、{\bf 標準入力}、{\bf 標準出力}、{\bf 標準エラー出力}の3つのデータの通り道が準備されます。このデータの通り道をチャネルといいます。

　チャネルに何も指定せずにコマンドを実行すると、標準入力はキーボードに設定されます。標準出力と標準エラー出力はディスプレイに設定されます。

\begin{figure}
    \vspace{5cm}
    \caption{ここにコマンドと標準入力・標準出力・標準エラー出力の図を入れる}
    \label{ch03:stdioerr}
\end{figure}

コマンドによっては、標準の入力をコマンドの引数として与えることができるものがあります。例えば cat などのコマンドは cat ファイル名 で指定したファイルを標準出力に出力します。cat にファイル名を指定しないと、標準入力、つまりからデータを受け取ります。

\begin{lstlisting}[caption=catの標準入力・標準出力, label=stdioCat]
<#green#pi@raspberrypi#>:<#blue#~ $#> cat 
aaaa <enter> <- 標準入力（キーボード）からの入力
aaaa         <- 標準出力（ディスプレイ）への出力
<Ctrl-d>     <- 標準入力からEOFを入力し、入力が終了したことを伝える
<#green#pi@raspberrypi#>:<#blue#~ $#>
\end{lstlisting}


\subsection{リダイレクト}
標準入力、標準出力、標準エラー出力の出力先は、ファイルに変更することができます。
この機能を使うと、ファイルからデータを読み込んだり、結果をファイルに保存したりすることが簡単にできるようになります。

標準出力を出力先は、ファイルに変更することができます。

\begin{figure}
    \vspace{5cm}
    \caption{ここにリダイレクトの概念図を入れる}
    \label{ch03:redirect}
\end{figure}


\begin{lstlisting}[caption=lsの出力をリダイレクトする, label=redirectLs]
ls 
ほげ　ほげほげ　げげげ
ls $\gt$ lsfile
cat lsfile
ほげ
ほげほげ
げげげ
\end{lstlisting}

「$\gt$」の後にファイル名を指定することで、
ファイルを作成し、そのファイルにコマンドの結果を保存します。
いつも画面で見ている結果を、リダイレクトでファイルに保存するように変更しました。


標準入力の入力元を、ファイルに変更することができます。
\begin{lstlisting}[caption=catコマンドにリダイレクトでファイルを入力する, label=redirectCat]
cat < lsfile
ほげ
ほげほげ
げげげ
\end{lstlisting}

今回はリダイレクトの練習のため、
catコマンドでファイル名を指定するのではなく、リダイレクトと同じことをしました。

\subsection{パイプライン}

パイプ記号「|」を使うことで、パイプ記号の前のコマンドの標準出力と、
パイプ記号の後のコマンドの標準入力をつなぐことができます。

\begin{figure}
    \vspace{5cm}
    \caption{ここパイプの概念図を入れる}
    \label{ch03:redirect}
\end{figure}


\begin{lstlisting}[caption=catコマンドにリダイレクトでファイルを入力する, label=redirectCat]
ls | less
\end{lstlisting}

lsした結果が一画面に収まらない場合は、1画面ずつ 表示する。

この方法では1ファイルが一行になるが、それは正しい結果である。


↓はフィルタ。
ラズパイのコマンドは、入力を受け取って、それを加工してから、出力をする。


\subsection{xargsによるコマンドの組み立て}


\section{パイプラインと文字列処理}

\subsection{出力をつくるコマンド}
\begin{tabular}{ll}
    コマンド & 動作 \\ \hline
    ls & ファイルやディレクトリを出力する \\
    du & ディレクトリの中のファイルの大きさを報告する\\
    wc & 入力の文字数・単語数・行数を出力する\\
    echo & 文字をそのまま出力する\\ \hline
\end{tabular}


\subsection{フィルタコマンド}
\begin{tabular}{ll}
    コマンド & 動作 \\ \hline
    cat & 入力をなにもせずに出力する \\
    tac & 行を逆順に出力する\\
    shuf & 行をランダムに入れ替えて出力する \\
    head & 先頭のいくつかの行を表示する \\
    tail & 末尾のいくつかの行を表示する\\
    sort & 行を順番にならべかえる\\
    grep & 検索パターンに一致する行を出力する\\ \hline
\end{tabular}


\subsection{置き換えをするコマンド}
\begin{tabular}{ll}
    コマンド & 動作 \\ \hline
    tr & 入力された文字を指定する方法で置き換えて出力する \\
    sed & 入力から指定するパターンを見つけ、それを置き換えて出力する \\ \hline
\end{tabular}


\section{その他の便利なコマンド}

\subsection{文字の置き換え}
% trコマンドの説明
文字を置き換えるためのコマンドとして、trコマンドを紹介します。
trコマンドを使うと、入力された文字列の中の指定した文字を、別の文字に置き換えて出力することができます。
trコマンドの\ruby{基本的}{き|ほん|てき}な使い方は、次の通りです。

\begin{lstlisting}[caption=trコマンドの基本的な使い方, label=tr_basic_usage]
tr 置き換え対象の文字 置き換え後の文字
\end{lstlisting}

ここで、「置き換え対象の文字」には、置き換えたい文字を指定します。「置き換え後の文字」には、置き換え後の文字を指定します。

% 実行例の説明
trコマンドの使い方を、段階的に見ていきましょう。

まず、3文字程度の置き換えから始めてみます。
「HELLO, WORLD!」という文字列があるとします。
この文字列の"H"、"E"、"L"を小文字の"h"、"e"、"l"に変えてみましょう。

\begin{lstlisting}[caption=3文字の置き換え, label=tr_3_chars]
<#green#pi@raspberrypi#>:<#blue#~ $#> echo "HELLO, WORLD!" | tr HEL hel
\end{lstlisting}

すると、次のような結果が表示されます。

\begin{lstlisting}[caption=3文字を置き換えた結果, label=result_tr_3_chars]
hellO, WORlD!
\end{lstlisting}

文字列中の"H"、"E"、"L"が"h"、"e"、"l"に置き換わっていることが分かります。

次に、アルファベット全体を大文字から小文字に置き換えてみましょう。

\begin{lstlisting}[caption=アルファベット全体の置き換え, label=tr_all_chars]
<#green#pi@raspberrypi#>:<#blue#~ $#> echo "HELLO, WORLD!" \
| tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz
\end{lstlisting}

この例では、trコマンドにアルファベットの大文字全てと対応する小文字全てを指定しています。
このコマンドを実行すると、次のような結果が表示されます。

\begin{lstlisting}[caption=アルファベット全体を置き換えた結果, label=result_tr_all_chars]
hello, world!
\end{lstlisting}

しかし、アルファベット全てを指定するのは面倒ですよね。
そこで、trコマンドでは、「A-Z」や「a-z」のように範囲指定を使うことができます。

\begin{lstlisting}[caption=範囲指定を使った置き換え, label=tr_range]
<#green#pi@raspberrypi#>:<#blue#~ $#> echo "HELLO, WORLD!" | tr A-Z a-z
\end{lstlisting}

このコマンドでも先程と同じ結果が表示されます。

このように、trコマンドを使うと、文字列の中の文字を簡単に置き換えることができます。

% 問題
それでは、次の問題に挑戦してみましょう。
\begin{enumerate}
    \addex{
        次の文字列の大文字を小文字に変換してみましょう。\\
        "I LOVE PROGRAMMING!"
    }
    \addex{
        次の文字列の小文字を大文字に変換してみましょう。\\
        "i love programming!"
    }
\end{enumerate}

\subsection{単語を置き換える}

sed s/xxx/yyy/g の説明

実行例の説明

問題

\subsection{計算をする}

コマンドの説明： echo \$(式)
\$()で式を囲むと、計算ができる。echoコマンドは引数で与えられた文字列をそのまま標準出力に出力する。計算は整数で行われる。


実行例の説明

問題

\subsection{コマンドに別名を付ける}

コマンドを打っていて、よく使うのに覚えにくいものがあったりします。
そんな時はコマンドに別名を付けてしまいましょう。これを英語ではalias(エイリアス)と言います。

例えば、

\begin{lstlisting}[caption=lsコマンド, label=lsAlias]
    ls -l
\end{lstlisting}

に ll という別名を付けたいとします。

コマンドに別名を付けるためにはにはホームディレクトリに .bash{\_}aliases というファイルを作成し編集しなければなりません。
mousepad を使って .bash{\_}aliases というファイルを作成し、編集します。
\begin{lstlisting}[caption=.bashaliasesを開く, label=openBashAliases]
    <#green#pi@raspberrypi#>:<#blue#~ $#> mousepad ~/.bash_aliases &
\end{lstlisting}

.bash{\_}aliases には、次のように記述し、保存します。
\begin{lstlisting}[caption=.bashaliasesの中身, label=bashAliasesContents]
    alias ll='ls -l'
\end{lstlisting}

保存が終わったら、.bash{\_}aliases を実行して、別名を適用しなければなりません。
.bash{\_}aliases を実行します。
\begin{lstlisting}[caption=.bashaliasesを実行, label=executeBashAliases]
    <#green#pi@raspberrypi#>:<#blue#~ $#> ~/.bash_aliases
\end{lstlisting}

別名を付けたコマンドを打ってみましょう。
\begin{lstlisting}[caption=別名の確認, label=confirmAlias]
    <#green#pi@raspberrypi#>:<#blue#~ $#> ll
\end{lstlisting}

別名を付けた元のコマンドも打ってみましょう。
\begin{lstlisting}[caption=元のコマンドの確認, label=confirmCommand]
    <#green#pi@raspberrypi#>:<#blue#~ $#> ls -l
\end{lstlisting}

同じ出力が出るはずです。

.bash{\_}aliases は正しい文法で記述しないとラズベリーパイが正しく動作しなくなるので注意して編集してください。

問題
