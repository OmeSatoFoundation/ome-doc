\newpage
\section{コマンドをつなげて\ruby{便利}{べん|り}に使う}
ラズパイにはコマンドをつなげて便利に使うための方法が\ruby{用意}{よう|い}されています。
コマンドをつなげると、いくつかの\ruby{処理}{しょ|り}を連続して行うことができるようになります。
まずは、コマンドが入力・出力をどのように行うのかを\ruby{理解}{り|かい}しましょう。
次に入出力を変更して、コマンドの入力と出力がどのように変わるのかを\ruby{理解}{り|かい}しましょう。
最後に、コマンドをいくつかつなげて、\ruby{複雑}{ふく|ざつ}な\ruby{処理}{しょ|り}をやってみましょう。

\begin{figure}[h]
    \centering
    \includesvg[width=0.8\linewidth]{images/chap03/std_in_out_err.svg}
    \caption{標準入力・標準出力・標準エラー出力の図}
    \label{ch03:stdioerr}
\end{figure}

\subsection{コマンドの\ruby{入出力}{にゅう|しゅつ|りょく}}
　コマンドを\ruby{実行}{じっ|こう}すると、{\bf \ruby{標準入力}{ひょう|じゅん|にゅう|りょく}}、{\bf \ruby{標準出力}{ひょう|じゅん|しゅつ|りょく}}、{\bf \ruby{標準}{ひょう|じゅん}エラー出力}の3つのデータの\ruby{通}{とお}り道が\ruby{準備}{じゅん|び}されます。このデータの\ruby{通}{とお}り道をチャネルといいます。

　チャネルに何も指定せずにコマンドを\ruby{実行}{じっ|こう}すると、\ruby{標準入力}{ひょう|じゅん|にゅう|りょく}はキーボードに\ruby{設定}{せっ|てい}されます。\ruby{標準出力}{ひょう|じゅん|しゅつ|りょく}と\ruby{標準}{ひょう|じゅん}エラー出力はディスプレイに\ruby{設定}{せっ|てい}されます。


コマンドによっては、\ruby{標準}{ひょう|じゅん}の入力をコマンドの引数として与えることができるものがあります。例えば cat などのコマンドは cat ファイル名 で\ruby{指定}{し|てい}したファイルを\ruby{標準出力}{ひょう|じゅん|しゅつ|りょく}に出力します。cat にファイル名を指定しないと、\ruby{標準入力}{ひょう|じゅん|にゅう|りょく}、つまりからデータを受け取ります。

\begin{lstlisting}[caption=catの標準入力・標準出力, label=stdioCat]
<#green#pi@raspberrypi#>:<#blue#~ $#> cat 
sansu <Enter> <- 標準入力（キーボード）からの入力
sansu         <- 標準出力（ディスプレイ）への出力
<Ctrl+D>      <- 標準入力からEOFを入力し、入力が終了したことを伝える
<#green#pi@raspberrypi#>:<#blue#~ $#>
\end{lstlisting}
EOFとはEnd Of File(エンドオブファイル)の\ruby{略称}{りゃく|しょう}でどこがファイルの最後なのかを教えるために使います。

\subsection{リダイレクト}
\ruby{標準入力}{ひょう|じゅん|にゅう|りょく}、\ruby{標準出力}{ひょう|じゅん|しゅつ|りょく}、\ruby{標準}{ひょう|じゅん}エラー出力の出力先は、ファイルに\ruby{変更}{へん|こう}することができます。
この\ruby{機能}{き|のう}を使うと、ファイルからデータを読み込んだり、結果をファイルに保存したりすることが\ruby{簡単}{かん|たん}にできるようになります。

\begin{figure}
    \centering
    \includesvg[width=0.8\linewidth]{images/chap03/redirect.svg}
    \caption{リダイレクトを表した図}
    \label{ch03:redirect}
\end{figure}

\begin{lstlisting}[caption=lsの出力をリダイレクトする, label=redirectLs]
<#green#pi@raspberrypi#>:<#blue#~ $#> ls 
<#blue#01  03         Desktop    Downloads  Pictures  Templates
02  Bookshelf  Documents  Music      Public    Videos#>
<#green#pi@raspberrypi#>:<#blue#~ $#> ls > lsfile
<#green#pi@raspberrypi#>:<#blue#~ $#> cat lsfile
01
02
03
Bookshelf
Desktop
Documents
Downloads
Music
Pictures
Public
Templates
Videos
lsfile
\end{lstlisting}

「>」の後にファイル名を指定することで、
ファイルを作成し、そのファイルにコマンドの結果を保存します。
いつも画面で見ている結果を、リダイレクトでファイルに保存するように\ruby{変更}{へん|こう}しました。

\ruby{標準入力}{ひょう|じゅん|にゅう|りょく}の入力元を、ファイルに\ruby{変更}{へん|こう}することができます。
\begin{lstlisting}[caption=catコマンドにリダイレクトでファイルを入力する, label=redirectCat]
<#green#pi@raspberrypi#>:<#blue#~ $#> cat < lsfile
01
02
03
Bookshelf
Desktop
Documents
Downloads
Music
Pictures
Public
Templates
Videos
lsfile
\end{lstlisting}

今回はリダイレクトの\ruby{練習}{れん|しゅう}のため、
catコマンドでファイル名を\ruby{指定}{し|てい}するのではなく、リダイレクトと同じことをしました。

\newpage
\subsection{パイプライン}\label{sec:pipelne}

パイプ\ruby{記号}{き|ごう}「|」を使うことで、パイプ記号の前のコマンドの\ruby{標準出力}{ひょう|じゅん|しゅつ|りょく}と、
パイプ記号の後のコマンドの\ruby{標準入力}{ひょう|じゅん|にゅう|りょく}をつなぐことができます。

\begin{figure}
    \centering
    \includesvg[width=0.8\linewidth]{images/chap03/pipe.svg}
    \caption{パイプを表した図}
    \label{ch03:pipe}
\end{figure}

\begin{lstlisting}[caption=lsコマンドの出力をパイプでlessコマンドに渡す, label=redirectCat]
<#green#pi@raspberrypi#>:<#blue#~ $#> ls | less
01
02
03
Bookshelf
Desktop
Documents
Downloads
Music
Pictures
Public
Templates
Videos
lsfile
\end{lstlisting}

lsコマンドはリダイレクトやパイプを使うと1ファイルが一行ずつ出力されるようになっています。
lessコマンドにlsコマンドの\ruby{標準出力}{ひょう|じゅん|しゅつ|りょく}を渡すことによってファイルやディレクトリを一画面に表示することができました。

\newpage
\begin{figure}[t]
    \centering
    \includesvg[width=0.8\linewidth]{images/chap03/xargs_command.svg}
    \caption{xargsコマンドを表した図}
    \label{ch03:xargs_command}
\end{figure}

\subsection{xargsによるコマンドの組み立て}

\ruby{標準入力}{ひょう|じゅん|にゅう|りょく}を受け取って、\ruby{標準出力}{ひょう|じゅん|しゅつ|りょく}を出力に出すコマンドをフィルタコマンドといいます。
xargsコマンドもフィルタコマンドのうちの一つです。
xargsコマンドは\ruby{標準入力}{ひょう|じゅん|にゅう|りょく}を受け取って実行したいコマンドの引数として渡すことができます。

\begin{lstlisting}[caption=xargsコマンドを使う準備をする]
<#green#pi@raspberrypi#>:<#blue#~ $#> cd 03/rensyu
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu $#> mkdir xargs
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu $#> cp ~/lsfile ./xargs
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu $#> cp ./kokugo/syousetu.txt ./xargs
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu $#> cd xargs 
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#> ls
<#magenta#lsfile  syousetu.txt#>
\end{lstlisting}
xargsコマンドを使うためのディレクトリを\textasciitilde /03/rensyu/xargsに作りました。

\newpage
\begin{lstlisting}[caption=xargsコマンドを使ってcatコマンドを使う]
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#> ls | xargs cat
01
02
03
Bookshelf
Desktop
                                           ...
このファイルは、インターネットの図書館、青空文庫（http://www.aozora.gr.jp/）で作られました。
入力、校正、制作にあたったのは、ボランティアの皆さんです。



https://www.aozora.gr.jp/cards/000121/files/628_14895.html
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#>
\end{lstlisting}
lsコマンドで取り出したファイル名をxargsコマンドに渡して、2つのファイルの中身を同時に見ることができました。

\subsection{xargsのオプション}
xargsのオプションの紹介の前にこの章で使うコマンドの説明をします。
\begin{description}
    \item[\texttt{seq}\textvisiblespace 数字1\textvisiblespace 数字2]\mbox{}\\
    数字1から数字2までの数字を出力します。
\end{description}

\begin{lstlisting}[caption=seqコマンド]
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#> seq 1 5
1
2
3
4
5
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#>
\end{lstlisting}
seqコマンドを使うことで、数字を\ruby{順番}{じゅん|ばん}に出力することができました。

\begin{description}
    \item[\texttt{echo}\textvisiblespace 文字]\mbox{}\\
    文字をそのまま出力します。
\end{description}

\begin{lstlisting}[caption=seqコマンド]
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#> echo hello
hello
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#>
\end{lstlisting}
echoコマンドを使うことで好きな文字を出力できました。

xargsにもオプションがいくつかあります。そのうち、よくつかわれるオプション3つを\ruby{紹介}{しょう|かい}します。

\begin{description}
    \item[\texttt{xargs}\textvisiblespace \texttt{-p}\textvisiblespace
                コマンド]\mbox{}\\
    どのようなコマンドが実行されるかを表示してくれます。
    <Enter>を押すと何もせずに終了。<y>を押すとコマンドを実行します。
\end{description}

\begin{lstlisting}[caption=xargsコマンドのオプションp]
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#> ls | xargs -p echo
echo lsfile syousetu.txt?...<Enter>
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#> ls | xargs -p echo
echo lsfile syousetu.txt?...<Y><Enter>
lsfile syousetu.txt
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#>
\end{lstlisting}

\begin{description}
    \item[\texttt{xargs}\textvisiblespace \texttt{-i}\textvisiblespace
                コマンド\textvisiblespace \{\}]\mbox{}\\
    \ruby{標準入力}{ひょう|じゅん|にゅう|りょく}を受け取って\{\}の中に1つづつ引数に当てはめます。
\end{description}

\begin{lstlisting}[caption=xargsコマンドのオプションi]
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#> ls | xargs -i echo {}
lsfile
syousetu.txt
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#>
\end{lstlisting}

\begin{description}
    \item[\texttt{xargs}\textvisiblespace \texttt{-L}\textvisiblespace
                数字\textvisiblespace コマンド]\mbox{}\\
    Lオプションは、xarg引数コマンドに一度に\ruby{展開}{てん|かい}されるデータの最大数を指定します。
    \ruby{標準出力}{ひょう|じゅん|しゅつ|りょく}から渡されたデータ数が、-Lで指定された数より大きい場合、全てのデータが\ruby{展開}{てん|かい}し終わるまで
    xargs引数コマンドが繰り返し実行されます。
    -iオプションと-Lオプションを一緒に使うことはできません。
\end{description}

\begin{lstlisting}[caption=xargsコマンドのオプションL]
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#> seq 1 5 | xargs -L 1 echo
1
2
3
4
5
<#green#pi@raspberrypi#>:<#blue#~/03/rensyu/xargs $#> seq 1 5 | xargs -L 2 echo
1 2
3 4
5
\end{lstlisting}

\begin{tcolorbox}[title=\useOmetoi]
    \begin{enumerate}
        \addex{catと入力して好きな文字を打ち込みましょう。}
        \addex{echo\textvisiblespace 好きな文字\textvisiblespace >\textvisiblespace
            rensyufile と入力して好きな文字をrensyufileに保存しよう。}
        \addex{リダイレクトの記号「<」を使ってrensyufileの中身を表示してみよう。}
        \addex{xargsを使って、rensyufileとlsfileを合体して表示してみよう。}
    \end{enumerate}
\end{tcolorbox}

\section{パイプラインと文字列処理}

\subsection{出力をつくるコマンド}
\begin{tabular}{ll}
    コマンド & 動作                                         \\ \hline
    ls       & ファイルやディレクトリを出力する             \\
    du       & ディレクトリの中のファイルの大きさを報告する \\
    wc       & 入力の文字数・単語数・行数を出力する         \\
    echo     & 文字をそのまま出力する                       \\ \hline
\end{tabular}

\subsubsection{duコマンド}
duコマンドは、ディレクトリやファイルの大きさを報告するコマンドです。

まず、duコマンドの使い方は、次の通りです。

\begin{lstlisting}[caption=duコマンドの使い方, label=du_usage]
du 大きさを調べたいディレクトリ、ファイルのパス
\end{lstlisting}

このコマンドを実行することで、パスに指定したディレクトリやファイルの大きさを表示します。

次に、具体的な例を見てみましょう。

\begin{lstlisting}[caption=duコマンドの実行例, label=du_example]
<#green#pi@raspberrypi#>:<#blue#~ $#> du ~/03
124	/home/pi/03/rensyu/rika
20	/home/pi/03/rensyu/kokugo
68	/home/pi/03/rensyu/sansu
256	/home/pi/03/rensyu/syakai
500	/home/pi/03/rensyu
980	/home/pi/03
\end{lstlisting}

この例では、\textasciitilde/03の中のディレクトリの中のディレクトリの大きさを報告しています。
左側の数字が各ディレクトリの大きさを表しています。
ただし、このままでは各数字がどれくらいの大きさを表しているのかがわかりにくいですよね。
そこで、-hオプションを使って、数字に単位を付与することができます。

\begin{lstlisting}[caption=du -hの実行例, label=du_example]
<#green#pi@raspberrypi#>:<#blue#~ $#> du -h ~/03
124K	/home/pi/03/rensyu/rika
20K	/home/pi/03/rensyu/kokugo
68K	/home/pi/03/rensyu/sansu
256K	/home/pi/03/rensyu/syakai
500K	/home/pi/03/rensyu
980K	/home/pi/03
\end{lstlisting}

このように、-hオプションを使うことで、数字に単位を付与することができます。
この例では、全てのディレクトリの大きさがキロバイトで表示されています。

また、この例では、ディレクトリの大きさのみを表示していますが、-aオプションを使うことで、ディレクトリ内のファイルの大きさも表示することができます。

\begin{lstlisting}[caption=du -haの実行例, label=du_example]
<#green#pi@raspberrypi#>:<#blue#~ $#> du -ha ~/03
24K     /home/pi/03/rensyu/rika/rika.png
96K     /home/pi/03/rensyu/rika/mokei.png
124K	/home/pi/03/rensyu/rika
4.0K	/home/pi/03/rensyu/kanji.txt
16K     /home/pi/03/rensyu/kokugo/syousetu.txt
20K     /home/pi/03/rensyu/kokugo
24K     /home/pi/03/rensyu/oda.jpg
60K     /home/pi/03/rensyu/sansu/nihon.png
4.0K	/home/pi/03/rensyu/sansu/sansu.txt
68K     /home/pi/03/rensyu/sansu
252K	/home/pi/03/rensyu/syakai/sekai.png
256K	/home/pi/03/rensyu/syakai
500K	/home/pi/03/rensyu
4.0K	/home/pi/03/Ltika.hsp
4.0K	/home/pi/03/led.hsp
4.0K	/home/pi/03/button_led2.hsp
4.0K	/home/pi/03/button.hsp
4.0K	/home/pi/03/button_led.hsp
4.0K	/home/pi/03/README.md
4.0K	/home/pi/03/button_led3.hsp
444K	/home/pi/03/rensyu.tar.gz
4.0K	/home/pi/03/sensors.hsp
980K	/home/pi/03
\end{lstlisting}

このように、-aオプションを使うことで、ディレクトリ内のファイルの大きさも表示することができます。
この実行例ではわかりやすさのためにhオプションも同時に使用しています。

最後に、-sオプションを用いてディレクトリの大きさの合計だけを表示する方法を紹介します。

\begin{lstlisting}[caption=du -hsの実行例, label=du_example]
<#green#pi@raspberrypi#>:<#blue#~ $#> du -hs ~/03
980K	/home/pi/03
\end{lstlisting}

このように、-sオプションを使うことで、ディレクトリの大きさの合計だけを表示することができます。
もし特定のディレクトリの合計容量を知りたい場合には、このオプションを使うと便利です。

\begin{tcolorbox}[title=\useOmetoi]
    \begin{enumerate}
        \addex{duコマンドを使って、\textasciitilde/02ディレクトリの大きさを表示してみましょう。}
        \addex{duコマンドを使って、\textasciitilde/02ディレクトリの中のファイルの大きさを表示してみましょう。}
        \addex{duコマンドを使って、\textasciitilde/02ディレクトリの中のファイルの大きさの合計だけを表示してみましょう。}
    \end{enumerate}
\end{tcolorbox}

\subsubsection{wcコマンド}
wcコマンドは、入力の文字数・単語数・行数を出力するコマンドです。

まず、wcコマンドの使い方は、次の通りです。

\begin{lstlisting}[caption=wcコマンドの使い方, label=wc_usage]
wc 対象のファイルのパス
\end{lstlisting}

このコマンドを実行することで、パスに指定したファイルの文字数・単語数・行数を表示します。
    
次に、具体的な例を見てみましょう。

\begin{lstlisting}[caption=wcコマンドの実行例, label=wc_example]
<#green#pi@raspberrypi#>:<#blue#~ $#> wc ~/lsfile
13 13 93 /home/pi/lsfile
\end{lstlisting}

この例では、\textasciitilde/lsfileの中身の文字数・単語数・行数を表示しています。
左から順に、行数、単語数、文字数、ファイルのパスを表しています。

\begin{tcolorbox}[title=\useOmetoi]
    \begin{enumerate}
        \addex{wcコマンドを使って、\textasciitilde/03/rensyu/kokugo/syosetsu.txtの中身の文字数・単語数・行数を表示してみましょう。}
    \end{enumerate}
\end{tcolorbox}

\subsection{フィルタコマンド}
\begin{tabular}{ll}
    コマンド & 動作                               \\ \hline
    cat      & 入力をなにもせずに出力する         \\
    tac      & 行を逆順に出力する                 \\
    shuf     & 行をランダムに入れ替えて出力する   \\
    head     & 先頭のいくつかの行を表示する       \\
    tail     & 末尾のいくつかの行を表示する       \\
    sort     & 行を順番にならべかえる             \\
    grep     & 検索パターンに一致する行を出力する \\ \hline
\end{tabular}

\subsubsection{tacコマンド}
tacコマンドは、行を逆順に出力するコマンドです。

まず、tacコマンドの使い方は、次の通りです。

\begin{lstlisting}[caption=tacコマンドの使い方, label=tac_usage]
tac 表示したいファイルのパス
\end{lstlisting}

このコマンドを実行することで、パスに指定したファイルの中身を逆順にして表示します。

次に、具体的な例を見てみましょう

\begin{lstlisting}[caption=tacコマンドの実行例, label=tac_example]
<#green#pi@raspberrypi#>:<#blue#~ $#> tac ~/lsfile
lsfile
Videos
Templates
Public
Pictures
Music
Downloads
Documents
Desktop
Bookshelf
03
02
01 
\end{lstlisting}

この例では、リスト\ref{redirectLs}で使用したlsfileの中身を逆順に表示してみました。

\begin{tcolorbox}[title=\useOmetoi]
    \begin{enumerate}
        \addex{\textasciitilde/03/rensyu/kokugo/syosetsu.txtの中身を逆順に表示してみましょう。}
    \end{enumerate}
\end{tcolorbox}

\subsubsection{shufコマンド}
shufコマンドは、行をランダムに入れ替えて出力するコマンドです。

まず、shufコマンドの使い方は、次の通りです。

\begin{lstlisting}[caption=shufコマンドの使い方, label=shuf_usage]
shuf 表示したいファイルのパス
\end{lstlisting}

このコマンドを実行することで、パスに指定したファイルの中身をランダムに入れ替えて表示します。

次に、具体的な例を見てみましょう。

\begin{lstlisting}[caption=shufコマンドの実行例, label=shuf_example]
<#green#pi@raspberrypi#>:<#blue#~ $#> shuf ~/lsfile
03
Desktop
Documents
02
Music
01
Videos
Pictures
Bookshelf
Templates
Public
lsfile
Downloads
\end{lstlisting}

この例では、リスト\ref{redirectLs}で使用したlsfileの中身をランダムに入れ替えて表示してみました。
実行するたびにランダムに入れ替わるので、この例とは異なる結果が表示されるかもしれません。

\begin{tcolorbox}[title=\useOmetoi]
    \begin{enumerate}
        \addex{\textasciitilde/03/rensyu/kokugo/syosetsu.txtの行をランダムに入れ替えて表示してみましょう。}
    \end{enumerate}
\end{tcolorbox}

\subsubsection{headコマンド}
headコマンドは、先頭のいくつかの行を表示するコマンドです。

まず、headコマンドの使い方は、次の通りです。

\begin{lstlisting}[caption=headコマンドの使い方, label=head_usage]
head 表示したいファイルのパス -n 行数
\end{lstlisting}

このコマンドを実行することで、パスに指定したファイルの中身の内、先頭の数行を表示します。
表示する行数は、nオプションの後に指定した行数に依存します。

次に、具体的な例を見てみましょう。

\begin{lstlisting}[caption=headコマンドの実行例, label=shuf_example]
<#green#pi@raspberrypi#>:<#blue#~ $#> head ~/lsfile -n 2
01
02
\end{lstlisting}

この例では、lsfileの中身の先頭の2行を表示してみました。

\begin{tcolorbox}[title=\useOmetoi]
    \begin{enumerate}
        \addex{\textasciitilde/03/rensyu/kokugo/syosetsu.txtの先頭の5行を表示してみましょう。}
    \end{enumerate}
\end{tcolorbox}

\subsubsection{tailコマンド}
tailコマンドは、末尾のいくつかの行を表示するコマンドです。

まず、tailコマンドの使い方は、次の通りです。

\begin{lstlisting}[caption=tailコマンドの使い方, label=tail_usage]
tail 表示したいファイルのパス -n 行数
\end{lstlisting}

このコマンドを実行することで、パスに指定したファイルの中身の内、末尾の数行を表示します。
表示する行数は、nオプションの後に指定した行数に依存します。

次に、具体的な例を見てみましょう。

\begin{lstlisting}[caption=tailコマンドの実行例, label=shuf_example]
<#green#pi@raspberrypi#>:<#blue#~ $#> tail ~/lsfile -n 2
Videos
lsfile
\end{lstlisting}

この例では、lsfileの中身の末尾の2行を表示してみました。

\begin{tcolorbox}[title=\useOmetoi]
    \begin{enumerate}
        \addex{\textasciitilde/03/rensyu/kokugo/syosetsu.txtの末尾の5行を表示してみましょう。}
    \end{enumerate}
\end{tcolorbox}

\subsubsection{sortコマンド}
sortコマンドは行を順番にならべかえるコマンドです。

まず、sortコマンドの使い方は、次の通りです。

\begin{lstlisting}[caption=sortコマンドの使い方, label=sort_usage]
sort 表示したいファイルのパス
\end{lstlisting}

パスに指定したファイルの中身を行ごとに並べ替えて表示します。

次に、具体的な例を見てみましょう。

\begin{lstlisting}[caption=sortコマンドの実行例, label=sort_example]
<#green#pi@raspberrypi#>:<#blue#~ $#> sort ~/lsfile
01
02
03
Bookshelf
Desktop
Documents
Downloads
lsfile
Music
Pictures
Public
Templates
Videos
\end{lstlisting}

この例では、lsfileの中身を順番に並べ替えて表示してみました。
数字とアルファベットが混在している場合、数字が先に表示され、その後にアルファベットが表示されます。

\begin{tcolorbox}[title=\useOmetoi]
    \begin{enumerate}
        \addex{\textasciitilde/02ディレクトリの中身をsortコマンドを使って並べ替えて表示してみましょう。 \\ ヒント:まず、02の中身を表示するコマンドの標準出力をリダイレクトでファイル書き込もう。次にsortコマンドを使ってファイルの中身を並べ替えてみよう。}
    \end{enumerate}
\end{tcolorbox}

\subsubsection{grepコマンド}
grepコマンドは、検索パターンに一致する行を出力するコマンドです。

まず、grepコマンドの使い方は、次の通りです。

\begin{lstlisting}[caption=grepコマンドの使い方, label=grep_usage]
grep 検索パターン 表示したいファイルのパス
\end{lstlisting}

パスに指定したファイルから、検索パターンに一致する行を表示します。

次に、具体的な例を見てみましょう。

\begin{lstlisting}[caption=grepコマンドの実行例, label=grep_example]
<#green#pi@raspberrypi#>:<#blue#~ $#> grep 03 ~/lsfile
<#red#03#>
\end{lstlisting}

この例では、lsfileの中身から"03"という文字列に一致する行を表示してみました。
このように、一致する行がある場合はその行のみが表示されます。
また、一致する文字列は赤字で表示されます。

\begin{tcolorbox}[title=\useOmetoi]
    \begin{enumerate}
        \addex{\textasciitilde/03/rensyu/kokugo/syosetsu.txtの中身から"ごんぎつね"という文字列に一致する行を表示してみましょう。}
    \end{enumerate}
\end{tcolorbox}

\subsubsection{パイプラインとフィルタコマンドを組み合わせた使い方}
これまでフィルタコマンドについて基本的な使い方を紹介してきました。
これらのフィルタコマンドは、節\ref{sec:pipelne}で勉強したパイプラインと組み合わせることでより便利に使うことができます。

まず、パイプラインとフィルタコマンドを組み合わせた使い方は次の通りです。

\begin{lstlisting}[caption=パイプラインを用いたフィルタコマンドの実行例, label=pipeline_filter]
標準出力を出すコマンド | フィルタコマンド
\end{lstlisting}

パイプラインを使うことで、標準出力を出すコマンドの結果をフィルタコマンドに渡すことができます。
また、更にパイプでフィルタコマンドを繋げることで、さらにフィルタリングを行うことができます。

次に、具体的な例を見てみましょう。
例えば、lsコマンドの標準出力をsortに渡すことで、ファイルの一覧を並び替える方法を紹介します。

\begin{lstlisting}[caption=パイプラインを用いたsortコマンドの実行例, label=sort_example]
<#green#pi@raspberrypi#>:<#blue#~ $#> ls ~/03 | sort
01
02
03
Bookshelf
Desktop
Documents
Downloads
lsfile
Music
Pictures
Public
Templates
Videos
\end{lstlisting}

この例では、lsコマンドで\textasciitilde/03の中身を表示し、その結果をsortコマンドに渡して並べ替えています。
lsfileをsortコマンドに渡した際と同じ結果が表示されていることが分かります。

\begin{tcolorbox}[title=\useOmetoi]
    \begin{enumerate}
        \addquiz{ls \$HOME | command1 \\ ホームディレクトリの中身を並び替えるように command1 を埋めましょう。}
        \addquiz{ls \$HOME | command1 | command2 Downloads \\ 1の結果から Downloads を検索するように command1 と command2 を埋めましょう。}
        \addquiz{cat \textasciitilde/03/rensyu/kokugo/syosetsu.txt | tail -n 数字1 | head -n 数字2 \\ syosetsu.txtの下から3行目を表示するように 数字1 と 数字2 を埋めましょう。}
    \end{enumerate}
\end{tcolorbox}

\subsection{置き換えをするコマンド}
\begin{tabular}{ll}
    コマンド & 動作                                                       \\ \hline
    tr       & 入力された文字を指定する方法で置き換えて出力する           \\
    sed      & 入力から指定するパターンを見つけ、それを置き換えて出力する \\ \hline
\end{tabular}

\section{その他の便利なコマンド}

\subsection{文字の置き換え}
% trコマンドの説明
文字を置き換えるためのコマンドとして、trコマンドを紹介します。
trコマンドを使うと、文字列中の特定の文字を、別の文字に置き換えることができます。
trコマンドの使い方は、次の通りです。

\begin{lstlisting}[caption=trコマンドの使い方, label=tr_basic_usage]
tr 置き換えたい文字 置き換える文字
\end{lstlisting}

ここで、「置き換えたい文字」には、置き換えたい文字を書きます。
「置き換える文字」には、新しく変える文字を書きます。
例えば、「置き換えたい文字」に "ABC"、「置き換える文字」に "XYZ" を書くと、"A" は "X" に、"B" は "Y" に、"C" は "Z"
に置き換わります。

% 実行例の説明
それでは、trコマンドの使い方を少しずつ見ていきましょう。

まず、3つの文字を置き換えるところから始めてみます。
"HELLO, WORLD!" という文字列があるとします。
この文字列の "H"、"L"、"W" を小文字の "h"、"l"、"w" に置き変えてみましょう。

\begin{lstlisting}[caption=3文字の置き換え, label=tr_3_chars]
<#green#pi@raspberrypi#>:<#blue#~ $#> echo "HELLO, WORLD!" | tr HLW hlw
hEllO, wORlD!
\end{lstlisting}

文字列中の "H"、"L"、"W" が "h"、"l"、"w" に置き換わっていることが分かります。

次に、アルファベットの大文字全てを小文字に置き換えてみましょう。

\begin{lstlisting}[caption=アルファベット全体の置き換え, label=tr_all_chars]
<#green#pi@raspberrypi#>:<#blue#~ $#> echo "HELLO, WORLD!" \
| tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz
hello, world!
\end{lstlisting}

この例では、trコマンドにアルファベットの大文字全てと対応する小文字全てを書きました。
また、この例で使用している "\textbackslash" は、コマンドを複数行に分けて書くための記号です。
コマンドの実行後、アルファベット全てが小文字に置き換わっていることが分かります。

しかし、アルファベット全てを書くのは大変ですよね。
そこで、trコマンドでは、連続するアルファベットや数字などに関して "A-Z" や "a-z"、"0-9"
のように範囲を指定することで簡潔に書くことができます。

\begin{lstlisting}[caption=範囲指定を使った置き換え, label=tr_range]
<#green#pi@raspberrypi#>:<#blue#~ $#> echo "HELLO, WORLD!" | tr A-Z a-z
hello, world!
\end{lstlisting}

このコマンドでも先程と同じ結果が表示されます。
ちなみに、範囲指定を使うときは次のことに気をつけましょう。
\begin{itemize}
    \item "-" は置き換えられない。
    \item 範囲は、"A" から "Z"、"a" から "z" のように、前の方の文字から後ろの方の文字へと順番に書きます。(例えば "Z-A"
          はエラーになります)
\end{itemize}

このように、trコマンドを使うと、文字列の中の文字を簡単に置き換えることができます。
また、trコマンドを使うことで文字の削除なども行うことができます。
興味がある人は、文字の置き換え以外にもどのような使い方ができるか、調べてみましょう。

% 問題
\begin{tcolorbox}[title=\useOmetoi]
    \begin{enumerate}
        \addex{次の文字列の大文字を小文字に変換してみましょう。\\ "I LOVE PROGRAMMING!"}
        \addex{次の文字列の小文字を大文字に変換してみましょう。\\ "i love programming!"}
    \end{enumerate}
\end{tcolorbox}

\subsection{単語を置き換える}
tr は一文字ごとの置き換えを処理できました。
それでは、単語など文字列、つまり複数の文字を置き換えたいときはどうしたらよいでしょう。
このために、また別なコマンドがあります。
sed コマンドです。

\begin{lstlisting}[caption=sed コマンドの基本的な使い方, label=sed_usage]
sed 's/置き換え対象の文字列/置き換え後の文字列/g'
\end{lstlisting}

tr コマンドと似たように、「置き換え対象の文字列」には、置き換えたい文字列を指定します。
「置き換え後の文字列」には、置き換え後の文字列を指定します。
tr コマンドと異なり、置き換えは一文字ずつではなく文字列を指定することができます。

再度「Hello, World!」という文章で例を示します。
この文章の「Hello」を「Hi」に置き換えたいときは、次のようにコマンドを入力します。

\begin{lstlisting}[caption=sed コマンドを使った例, label=sed_app]
<#green#pi@raspberrypi#>:<#blue#~ $#> echo "Hello, World!" | sed 's/Hello/Hi/g'
\end{lstlisting}

すると、次のような結果が表示されます。

\begin{lstlisting}[caption=sed コマンドで変換した結果, label=sed_result]
Hi, Wowld!
\end{lstlisting}

それでは、次の問題に取り組んでみましょう。

\begin{tcolorbox}[title=\useOmetoi]
\begin{enumerate}
    \addex{%
        次の文章の「like」を「love」に置き換えましょう。\\%
        ``I like programming!"%
    }
    \addex{%
\textasciitilde /03/rensyu/kokugo/syosetsu.txt には小説「ごんぎつね」が掲載されています。%
「ごんぎつね」に登場するキャラクター「ごん」の名前を「Fox」に変えて標準出力に出力しましょう。\\%
ヒント: cat \textasciitilde /03/rensyu/kokugo/syosetsu.txt | sed ???%
}
\end{enumerate}
\end{tcolorbox}

さて、リスト \ref{sed_usage} には変換する文字列や仕切り文字 / の他に、
s や g といった文字がついているのに気付いたでしょうか。
実は sed は文字列を置き換える以外にも様々な機能を持ちます。
今回は sed に含まれる s と g というコマンドを用いて文字列を置き換えましたが、
そのほかにもパターンスペースを削除する d やパターンスペースを表示する p など様々なコマンドが sed には収録されています。
興味がある人は

\begin{lstlisting}
<#green#pi@raspberrypi#>:<#blue#~ $#> man sed
\end{lstlisting}

と実行してオンラインマニュアル (英語) を閲覧したり、ブラウザで「sed 使い方」などと検索してみたりしましょう。

\subsection{計算をする}

\noindent
{\bf echo\textvisiblespace\$(コマンド) }

%注マージ後ページ参照を解決
22ページでは、echoコマンドは\ruby{引数}{ひき|すう}で与えられた\ruby{文字列}{も|じ|れつ}をそのまま\ruby{標準}{ひょう|じゅん}出力に出力するコマンドとして\ruby{登場}{とう|じょう}しました。
今回は他のコマンドの\ruby{実行結果}{じっ|こう|けっ|か}をechoコマンドの引数に与えて、それを\ruby{標準}{ひょう|じゅん}出力に出力します。
コマンドの中で使用される \$() はコマンド\ruby{置換}{ち|かん}を行うための\ruby{構文}{こう|ぶん}です。コマンド\ruby{置換}{ち|かん}を使用すると、中のコマンドの\ruby{実行結果}{じっ|こう|けっ|か}を、別のコマンドの\ruby{引数}{ひき|すう}として使用することができます。
\begin{lstlisting}[caption=echo コマンド置換を使った例1, label=cmdsbs:echo]
<#green#pi@raspberrypi#>:<#blue#~/ $#> echo $(ls)
\end{lstlisting} 

\begin{lstlisting}[caption=lsコマンドの出力, label=cmdsbs:ls]
<#green#pi@raspberrypi#>:<#blue#~/ $#> ls
\end{lstlisting}

二つのコマンドから同じ\ruby{結果}{けっ|か}を\ruby{得}{え}られることがわかります。\$()の中に書いたコマンドが実行されます。
echoコマンドとコマンド\ruby{置換}{ち|かん}の他の使い方を見てみましょう。echo \$((式))と打つと\ruby{計算結果}{けい|さん|けっ|か}を出力してくれます。

ここで内側にも()があることに注意しましょう。この()は内側の\ruby{算術式}{さん|じゅつ|しき}の\ruby{評価結果}{ひょう|か|けっ|か}を変数として\ruby{認識}{にん|しき}して、その変数の中身をechoの\ruby{引数}{ひき|すう}に渡すために使用します。つまり、計算の結果を表示をするためのものです。
ターミナルでの計算には、足し算（$+$）、引き算（$-$）、掛け算（$*$）、割り算（$/$）などが利用できます。 割り算は商のみを\ruby{整数}{せい|すう}で出力しますので注意してください。

$138+395$の計算を実行すると次のような出力が得られます。
\begin{lstlisting}[caption=echo コマンドを使った例2, label=cmdsbs:calc]
<#green#pi@raspberrypi#>:<#blue#~ $#> echo $((138 + 395))
533
\end{lstlisting}

このようにコンピュータが計算してくれると、電卓を取り出して計算しなくてもよいので便利ですね。

\vskip\baselineskip

\begin{tcolorbox}[title=\useOmetoi]
    それでは、次の問題に取り組んでみましょう。
    \begin{enumerate}
        \addquiz{$2024 - 727$}
        \addquiz{$117 \times 13$}
        \addquiz{$(84 + 67 + 49 + 96) \div 4$}
    \end{enumerate}
\end{tcolorbox}
\subsection{コマンドに別名を付ける}

コマンドを打っていて、よく使うのに覚えにくいものがあったりします。そんな時はコマンドに別名を付けてしまいましょう。これを英語では alias (エイリアス)と言います。エイリアスは alias コマンドで追加できます。

\begin{description}
\item[\texttt{alias}\textvisiblespace 名前='コマンド']\mbox{}\\
コマンドの別名として名前を設定します。コマンドの両脇の小さい点をシングルクオーテーションと呼びます。
\end{description}

では、使用例を見てみましょう。例えば、

\begin{description}
\item[\texttt{ls}\textvisiblespace -alF]
\end{description}

に l (小文字のL)という別名を付けたいとします。つまり、l と実行したら ls -alF が実行されるようにしたいということです。

\begin{lstlisting}[caption=aliasコマンドの例, label=aliasCommandExample]
<#green#pi@raspberrypi#>:<#blue#~ $#> alias l='ls -alF'
<#green#pi@raspberrypi#>:<#blue#~ $#>
\end{lstlisting}

何も出力がなければ別名の設定が完了しています。別名を付けたコマンドを入力してみましょう。

\begin{lstlisting}[caption=別名の確認, label=confirmAlias]
<#green#pi@raspberrypi#>:<#blue#~ $#> l
\end{lstlisting}

別名を付けた元のコマンドも入力してみましょう。

\begin{lstlisting}[caption=元のコマンドの確認, label=confirmCommand]
<#green#pi@raspberrypi#>:<#blue#~ $#> ls -alF
\end{lstlisting}

同じ出力が得られるはずです。しかし、bash を閉じると今設定した別名は消えてしまいます。

別名を保存しておくには、ホームディレクトリに .bash{\_}aliases というファイルを作成し\ruby{編集}{へん|しゅう}します。なぜかというと、bash は起動時に \textasciitilde/.bash{\_}aliases というファイルの中に書いてあるコマンドをすべて実行してくれるからです。

.bash{\_}aliases には、次のようにコマンドを\ruby{記述}{き|じゅつ}し、保存します。
\begin{lstlisting}[caption=\textasciitilde/.bash\_aliasesの書き方1, label=bashAliasesGrammar1]
alias 名前='コマンド'
alias name='command'
            :
            :
\end{lstlisting}

保存が終わったら、.bash{\_}aliases の中のコマンドを実行することで、別名を\ruby{適用}{てき|よう}します。source というコマンドで .bash{\_}aliases の中のコマンドを実行します。
\begin{lstlisting}[caption=\textasciitilde/.bash\_aliasesの読込, label=sourceBashAliases]
<#green#pi@raspberrypi#>:<#blue#~ $#> source ~/.bash_aliases
<#green#pi@raspberrypi#>:<#blue#~ $#>
\end{lstlisting}

上のように実行して何も表示されなければ正常に\ruby{適用}{てき|よう}できています。

% alias コマンドにシングルクオーテーションが必要なのは、次のように記述できるからです。
% \begin{description}
%     \item[\texttt{alias}\textvisiblespace 名前 = 'コマンド'\textvisiblespace name = 'command'\textvisiblespace ...]\\
%     設定したいコマンドにスペースが含まれていた場合、bash はスペースの後の文字列を新たな別名として\ruby{認識}{にん|しき}し、\ruby{意図}{い|と}とは異なった別名を設定しようとします。
% \end{description}

\begin{itemize}
    \item[<補足1>] bash が\ruby{起動}{き|どう}したとき、\textasciitilde/.bashrc というファイルの中身が自動で実行されます。\\
    さらにその中で \textasciitilde/.bash{\_}aliases の中身を実行する\ruby{記述}{き|じゅつ}があります。ただし、\\
    そのタイミングでしか読み込まれないので、ファイルを\ruby{編集}{へん|しゅう}した後に読み込みなおす\\
    必要があります。また、\textasciitilde/.bash{\_}aliases に上で述べたように正しく\ruby{記述}{き|じゅつ}しないと、\\
    bash \ruby{起動}{き|どう}時に毎回エラーメッセージが表示されるようになります。正しく\ruby{記述}{き|じゅつ}するように\\
    しましょう。
    \item[<補足2>] source コマンドは\ruby{引数}{ひき|すう}として渡されたファイルの中身を bash コマンドとして実行します。\\
    つまり、ファイルの中に書いてあるコマンドを手打ちで実行していくのと変わらないのです。
\end{itemize}

\begin{tcolorbox}[title=\useOmetoi]
    \begin{enumerate}
        \addex{
            rm\textvisiblespace -i というコマンドに rm と別名を付けてみましょう。
            (オプション) bash を\ruby{再起動}{さい|き|どう}しても別名が残るようにしてみましょう。
        }
        \addex{
            好きなコマンドに好きな別名を付けてみましょう。
        }
    \end{enumerate}
\end{tcolorbox}